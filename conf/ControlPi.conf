# Global ControlPi Config.
# 

# Hardware config.
#  For now only support "PiFaceDigital"
#  use_module=PiFaceDigital #[PiFaceDigital, none] is not yet implemented.
#  You can make a Hardware module on you own and compile from source.
#  PiFaceDigital has 8 inputs and 8 outputs.
#  When instanceKey=H & inputEntityKey=i  you can assign a output  like Ho0=1 | 0   ... (see examples in logic.conf)
#  Inputs are the same. To control Output 4 with input 2 or input 7:  Ho4=[Hi2] | [Hi7]
#
context=Hardware
use_module=PiFaceDigital #[PiFaceDigital, none]
instanceKey=H
inputEntityKey=i
expose_read  = public  # Hardware input events are publicly availible.
expose_write = none    # Write access should not be granted. Because they might conflict/override/be instantly overridden by  real hardware events.
outputEntityKey=o
expose_read  = public   # Output events are visible publicly as well..
#expose_write = none    # Write Access is disabled (see above); "none" is the default value for ommited rights.


# Timers Config
#  One instanceKey enables a set of timers (0 - 7) on which can be refered to in logic.conf as first letter.
#  So instanceKey=T allows to set timer=0-7
#  If you add another instanceKey (e.g. instanceKey=S ) you get another set of 7.
#  The values for the timers are configured in a seperate config file (timers.conf)
#
context=Timer
instanceKey=T
inputEntityKey=t
outputEntityKey=o

# Memory IO-Channel
#  when instanceKey is 'M' and duplexEntityKey is set to 'a' 
#  you would access it [Ma0] to [Ma7]. 
#  If You need more than 7 Memorys, add another duplexEntityKey e.e. 'b'
#  then you can use another 7 Memorys, from [Mb0] to [Mb7] 

context=Memory
instanceKey=M
duplexEntityKey=a
#duplexEntityKey=b
#duplexEntityKey=c

# Networking
# On default a WebSocket Server is active.
# Brief: Connected clients receive updates on the status of resources and can write to them, if they have the right permission
#    Authentication model:
#    - A newly connected client automatically has level 'public'.
#    - A client can upgrade to level  'private' for one whole entityKey (e.g 'H') by authorizing.
#    Read-access:
#    - Entitys that specify "expose_read" as "public"  will broadcast their values to all client.
#    - Entitys that specify "expose_read" as "private" will only send their values to authorized clients.
#    - Entitys that specify "expose_read" as "none"    will not send their values to anyone.
#    Write-access:
#    - Entitys that specify "expose_read" as "public"  will grant write access to everyone.
#    - Entitys that specify "expose_read" as "private" will grant write access only to authorized clinets.
#    - Entitys that specify "expose_read" as "none"    will not grant write permission to anyone.
#    Writing syntax: "set:ContextEntity[#Num]:0-1 or 0-255
#    - set:Pi0:1 == set:Pi0:high == set:Pi0:true to set Pin 0 of Pipe0
#    - set:Pi:170  (= 0xAA => 10101010 = every second input high, others 0)
#    - set:Pi:125  (= 0x55 => 01010101 = every second input high, others 0)
#    Authorisation:
#    - One can authorize for a Channel (and so become 'private')  by sending "auth:<instanceKey>:<private_token>"
#      The authorisation is only valid ONE Channel including all of their entities
#      The authorisation can ony be revoked by dis-/reconnecting.
#    Example (1):
#     Context Hardware's instanceKey 'H' has two entities: 'i' and 'o'.
#     Both specify expose_read as public, but expose_write to none.
#     So the values are sent out to anyone, but no one can write.
#     Also it does noes not need to specify a private_token;
#     No entity is set to private, so there's nothing to authorize for.
#    Example (2):
#     Context Pipe (this is a Context made for Networking).
#     It has two entities 'i' and 'o'. Both are public readable (expose_read=public).
#     As the output is supposed to lead towards the frontend, it should not be writable. (expose_write=none)
#     But 'o' sets expose_write to private. Also context Pipe specifies a private_token=r7123d97a3
#     Assuming we want to write to [Po1] we first would have to send "auth:P:r7123d97a3".
#     After that we could send set:Pi1:1 to set the value of Pipe's output entity #1 to 1 / true.
#      -Both examples would broadcast their values to any active client in JSON Format
#       e.g. {"Po" : "170", "Pi" : "4", "Ho" : "0", "Hi" : "6"}
#    Example (3):
#     Another Pipe, let's call it 'Q' has everything set to private. private_token is set to 12345
#     So it's 'invisible' to public users. They dont see updats on it and set values on it.
#     Once one send "auth:Q:1234" one start receiving updates on it. Also now you can write to it.
#     {"Qo" : 4, "Qi" : 1}  # (The expose_private Channels come as a seperate message before the broadcast, due to implementation.)
#     {"Po" : "170", "Pi" : "4", "Ho" : "0", "Hi" : "6"}
#

context=Network
active=true
address=127.0.0.1
port=8080
docr= ./www/



# Pipe Config
# Pipes are entitys dedicated to Network acces via a WebSocket client.
context=Pipe
instanceKey=P
inputEntityKey=i
expose_read  = public             #public = broadcasted to everyone, private = broadcasted only to token holder(s), none= not exposed at all.
expose_write = private            #public = anyone can write, private = only token holder can write, none = no one can write-
outputEntityKey=o
expose_read = public
expose_write = none
private_token = r7123d97a3 #Token needed to gain "private" privileges. Can be anything. Be careful with special-chars.


